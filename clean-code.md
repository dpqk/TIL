코드가 존재하리라
=================
- 코드는 요구사항을 상세히 표현하는 수단
- 제대로 명시된 요구사항은 코드만큼 정형적이며 테스트 케이스로 사용해도 좋다.              
- __고행(wading): 나쁜 코드를 헤쳐나간다.__
- *르블랑의 법칙(leblanc's Law): 나중은 결코 오지 않는다.*   
   
- 나쁜코드가 쌓일수록 팀 생산성을 떨어진다. 마침내 0에 근접한다.   
   
- 환자가 수술전에 손을 씻지말라고 요구한다 -> 환자말을 따르는 행동은(범죄일 뿐만 아니라) 전문가 답지 못하다. 
  - 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다.   
   
- *논리가 간단해야 버그가 숨어들지 못한다. [비야네 스트롭스트룹]*
- 나쁜코드는 나쁜 코드를 '유혹'한다!
- *깨끗한 코드는 누군가 주의 깊게 짰다는 느낌을 준다. 고치려고 살펴봐도 딱히 손 댈 곳이 없다.[마이클 페더스]*   
   
- __코드는__
  - 모든 테스트를 통과한다.
  - 중복이 없다.
  - 시스템 내 모든 설계 아이디어를 표현한다.
  - 클래스, 메서드, 함수 등을 최대한 줄인다.   
   
- *코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다.[워드 커닝햄]*   
   
- _보이스카우트 규칙 : 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라!_      


의미 있는 이름
==============
- 의도가 분명하게 이름을 지어라.
- 프로그래머는 코드에 그릇된 단서를 남겨서는 안된다.
- 발음하기 쉬운 이름을 사용하라.
- 긴 이름이 짧은 이름보다 좋다. 검색하기 쉬운 이름이 상수보다 좋다.
- 인코딩을 피하라 -> 거의 발음하기 어려우며 오타가 생기기도 쉽다.   
   
- 자신의 기억력을 자랑하지 마라
  - 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 그 변수 이름은 바람직하지 못하다.   
   
- 전문가 프로그래머 : 명료함이 최고.   
   
- 기발한 이름은 피하라.
  - 재미난 이름보다 명료한 이름을 선택하라.
  - 의도를 분명하고 솔직하게 표현하라.   
   
- 한 개념에 한 단어를 사용하라.
  - 일관성 있는 어휘로 코드를 작성할 것!   
   
- 말장난을 하지마라.
  - 한 단어를 두 가지 목적으로 사용하지 마라.
  - 대충 훑어봐도 이해할 코드 작성이 목표.   
   
- 해법, 문제 영역에서 가져온 이름을 사용하라.
  - 해법 : 기술 개념에는 기술 이름이 가장 적합한 선택이다.
  - 문제 : 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 한다.   
   
- 불필요한 맥락을 없애라.
  - 의미가 분명한 경우에 한해서 불필요한 맥락을 추가하지 않도록 한다.   
   
- 좋은 이름을 선택하려면 설명 능력이 뛰어나야 하고, 문화적인 배경이 같아야한다.
- 좋은 이름은 선택하는 건 기술, 비즈니스, 관리 문제가 아닌 교육 문제.   
   
- 다른 사람이 짠 코드를 손본다면 리팩터링 도구를 사용해 문제 해결 목적으로 이름을 개선하라.   
   
   
함수
====
- 어떤 프로그램이든 가장 기본적인 단위가 함수다.
   
- 작게 만들어라!
  - 함수를 만드는 규칙, 작게 더 작게!
  -  100줄이 넘어서고 안되고, 20줄도 길다.
   
- 각 함수는 이야기 하나를 표현.
- 한가지만 해라!
  - 함수는 한 가지를 해야한다. 그 한가지를 잘 해야한다. 그 한 가지만을 해야한다.
  - 한가지: 추상화 수준이 한가지!
   
- 한가지만 하는 함수는 섹션으로 나누기 어렵다.
   
- *코드는 위에서 아래로 이야기처럼 읽혀야 좋다. [내려가기 규칙]*
   
- Switch문을 피할 방법은 없지만, 저차원 클래스에 숨기고 절대로 반복하지 않도록 사용한다.
  - 다형성을 이용!
   
- __Single Responsibility Priciple(단일 책임 원칙)__
  - 객체 지향 프로그래밍에서 모든 클래스는 하나의 책임만 가지며, 그 클래스는 완전히 캡슐화 하여햐 한다.
- __Open Closed Principle(개방-폐쇄 원칙)__
  - 소프트웨어 객체는 확장에 대해 열려 있어야하고, 수정에 대해서는 닫혀있어야 한다.
   
- 서술적인 이름을 사용하라!
  - 서술적이고 긴 이름 (O)
  - 짧고 어려운 이름 (X)
  - 서술적인 주석 (X)
   
- 함수에서 이상적인 인수 개수는 0(무항)개다.
  - 4개 이상은 특별한 이유가 있어도 사용하면 안 된다.
  - 최선은 인수가 없는 경우이며, 차선은 입력 인수가 1개
   
- 이벤트 함수는 이벤트라는 사실이 코드에 명확히 드러나야 한다.
   
- 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.
   
- 플래그 인수는 추하다.
  - 함수로 부울 값을 넘기는 관례는 좋지 않다.
   
- 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언한다.
   
- 함수에 인수 이름을 넣으면 기억하기 쉽다.
   
- 부수 효과를 일으키지 마라!
- 일반적으로 출력 인수는 피해야한다.
   
- 명령과 조회를 분리하라.
  - 애초에 분리를 통해 혼란되지 않도록 만든다.
   
- 오류코드보단 예외를 사용하라.
- Try/Catch 블록은 코드 구조에 혼란을 일으킨다.
  - 별도 함수로 뽑아내는 편이 좋다.
   
- 오류 처리도 한가지 작업이다.
  - 오류를 처리하는 함수는 오류만 처리해야 마땅하다.
   
- 반복하지 마라!
  - 중복은 소프트웨어에서의 악의 근원이다.
   
- 구조적 프로그래밍
  - *모든 함수와 함수 내 모든 블록에 입구와 출구는 하나만 존재해야 한다.[Edsger Dijkstra]*
  - 루프 안에서 break나 continue를 사용해선 안 된다.
   
- 함수는 처음부터 탁 짜내지지는 않는다.
   
- __시스템 : 구현할 프로그램이 아니라 풀어갈 이야기.__
  - 프로그래밍 언어를 통해 더 풍부하고 표현력이 강한 언어를 만들어 이야기를 풀어간다.
   
   
주석
====
- *나쁜 코드에 주석을 달지 마라. 새로짜라. [브라이언 W.커니핸, P.J.플라우거]*
   
- 주석은 기껏해야 필요악이다.
  - 프로그래밍 언어를 치밀하게 사용해 의도를 표현할 능력이 있다면, 주석은 거의 필요하지 않다.
  - 주석은 언제나 실패를 의미한다.
  - 주석은 거짓말을 한다.
   
- 부정확한 주석은 아예 없는 주석보다 훨씬 더 나쁘다.
   
- 주석은 나쁜 코드를 보완하지 못한다.
  - 주석을 추가하는 이유 : 코드 품질이 나쁘기 때문
  - 자신이 저지른 난장판을 주석으로 설명하려 애쓰는 대신, 난장판을 깨끗이 치우는데 시간을 보내라!
   
- 코드로 의도를 표현하라.
   
- 좋은주석
  - 정말로 좋은 주석은, 주석을 달지 않을 방법을 찾아낸 주석!
  - 의도를 설명하는 주석
  - 의미를 명료하게 밝히는 주석
  - 결과를 경고하는 주석.
    - 프로그래머에게 결과를 경고 할 목적으로 주석을 사용한다.
  - TODO 주석
    - '앞으로 할 일'을 //TODO 주석으로 남겨두면 편하다.
    - 어떤 용도로 사용하든 시스템에 나쁜 코드를 남겨 놓는 핑계가 되어서는 안 된다.
  - 중요성을 강조하는 주석
    - 자칫 대수롭지 않다고 여겨질 뭔가의 중요성을 강조하기 위해서도 주석을 사용!
   
- 나쁜주석
  - 주절거리는 주석
    - 주석을 달기로 결정했다면 충분한 시간을 들여 최고의 주석을 달도록 노력한다.
  - 같은 이야기를 중복하는 주석
  - 오해할 여지가 있는 주석
  - 의무적으로 다는 주석
  - 이력을 기록하는 주석
    - 소스 코드 관리 시스템이 없을때는 바람직한 관례, 이제는 혼란만 가중할 뿐 제거하는 편이 좋다.
  - 있으나 마나 한 주석
    - 주석으로 분풀이를 하는 대신 프로그래머가 코드 구조를 개선하는게 낫다.
  - 무서운 잡음
    - 때로는 Javadocs도 잡음이다.
  - 위치를 표시하는 주석
    - 뒷부분에 슬래시(/)로 이어지는 잡음은 제거하는 편이 좋다.
  - 닫는 괄호에 다는 주석
    - 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만,
    - 함수를 줄이려 시도하자.
    - 작고 캡슐화된 함수에는 잡음.
  - 공로를 돌리거나 저자를 표시하는 주석
  - 주석으로 처리한 코드
    - 소스 코드 관리 시스템이 우리를 대신해 코드를 기억해준다. 삭제할 것.
  - HTML 주석
    - 주석에 HTML을 삽입해야 하는 책임은 프로그래머가 아니라 도구가 져야한다.
  - 전역정보
    - 주석을 달아야 한다면 근처에 있는 코드만 기술하라.
  - 너무 많은 정보
    - 관련 없는 정보를 장황하게 늘어놓지 마라.
  - 모호한 관계
    - 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.
  - 함수헤더
    - 이름을 잘 붙인 짧은 함수는 긴 설명이 필요없다.
   
   
형식 맞추기
===========
- 코드 형식은 중요하다!
   
- 적절한 행 길이를 유지하라.
- 길지 않은 소스로도 시스템을 구축할 수 있다.
   
- 신문 기사처럼 작성하라
  - 이름은 간단하면서도, 설명이 가능하게 짓는다.
   
- 개념은 빈 행으로 분리하라.
  - 빈 행은 새로운 개념을 시작한다는 시각적 단서다.
   
- 세로 밀집도
  - 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미
   
- 수직 거리
  - 서로 밀접한 개념은 세로로 가까이 둬야한다
- 변수 선언
  - 변수는 사용하는 위치에 최대한 가까이 선언한다.
- 인스턴스 변수
  - 인스턴스 변수는 클래스 맨 처음에 선언한다.
- 종속 함수
  - 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
  - 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.
- 개념적 유사성
  - 친화도가 높을수록 코드를 가까이 배치한다.
  - 종속성, 비슷한 동작을 수행
   
- 가로 형식 맞추기
  - 120자 정도로 행 길이를 맞추기.
   
- 가로 공백과 밀집도
  - 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.
   
- 가로 정렬
  - 선언문과 할당문을 별도로 정렬하게되면 코드가 엉뚱한 부분을 강조해 진짜 의도가 가려지게 된다.
  - 정렬이 필요할 정도로 목록이 길다면 문제는 목록 길이지 정렬 부족이 아니다.
   
- 들여쓰기
  - 범위로 이뤄진 계층을 표현하기 위해 코드를 들여쓴다.
  - 간단한 if문, 짧은 while문에서도 들여쓰기를 무시하지 말자.
   
- 가짜 범위
  - 빈 while문, for문에서 빈 블록을 올바로 들여쓰고 괄호로 감싸준다.
   
- 팀 규칙
  - 개개인이 따로국밥처럼 맘대로 짜대는 코드는 피해야한다.
   
- 밥 아저씨의 형식 규칙 
  - 코드 자체가 최고의 구현 표준 문서가 되는 예.
      
      
객체와 자료 구조
================
- 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다.
  - 구현을 감추려면 추상화가 필요하다!
   
- 사용자가 구현을 모른채 자료의 핵심을 조회할 수 있어야 진정한 의미의 클래스다.
- 자료를 세세하게 공개하기 보다는 추상적인 개념으로 표현하는 편이 좋다.
   
- *절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.*
- *객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.*
   
- *절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야한다.*
- *객체지향 코드는 새로운 함수를 추가하기 쉽다. 그러려면 모든 클래스를 고쳐야한다.*
   
- __객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며,__
- __절차적인 코드에서 어려운 변경은 객체지향에서 쉽다.__
   
- *디미터 법칙 : 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.*
   
- *기차 충돌 : 여러 객차가 한줄로 이어진 기차처럼 보여지는 조잡하다 여겨지는 코드는 피하는 편이 좋다.*
   
- 잡종 구조
  - 양쪽에서 단점만 모아놓은 구조, 프로그래머가 함수나 타입을 보호할지 공개할지 확신하지 못해 어중간하게 내놓은 설계
   
- __구조체 감추기__
```
ctxt.getAbsolutePathOfScratchDirectoryOption();
ctxt.getScratchDirectoryOption.getAbsolutePath();
```
  - ctxt에 공개해야하는 메서드가 너무 많아진다.
  
```
BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);
```
  - ctxt객체에 임시 파일을 생성하도록 한다.
  - ctxt는 내부 구조를 드러내지 않으며, 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색 할 필요가 없다.
   
- 자료 전달 객체
  - 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다.
    - DTO : 흔히 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 단계에서 처음으로 사용하는 구조체.
- 활성레코드
  - DTO의 특수한 형태.
  - 활성 레코드에 비지니스 규칙 메서드를 추가해 자료 구조를 객체로 취급하는 방식은 바람직하지 않다.
    - 활성 레코드는 자료 구조로 취급.
    - 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체를 따로 생성한다.
   
- __객체는 동작을 공개하고 자료를 숨긴다.__
  - 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉽다.
  - 기존 객체에 새 동작을 추가하기는 어렵다.
   
- __자료구조는 별다른 동작 없이 자료를 노출한다.__
  - 기존 자료 구조에 새 동작을 추가하기는 쉽다.
  - 기존 함수에 새 자료 구조를 추가하기는 어렵다.
  

      
  
