# 시스템
 - **복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다.**
 
 - 도시를 세운다면?
   - 도시가 돌아가는 이유는 적절한 추상화와 모듈화 때문이다.
   - 높은 추상화 수준, 시스템 수준에서도 깨끗함을 유지해야 한다.
 
 - 시스템 제작과 시스템 사용을 분리하라
   - 제작(construction)과 사용(use)는 아주 다르다는 사실을 명심한다.
   - 시작 단계는 모든 애플리케이션이 풀어야 할 관심사(concern)다.
 ```
 public Service getService() {
     if(service == null)
         service = new MyServiceImpl(...); // 모든 상황에 적합한 기본값일까?
     return service;
 }
 ```
   - 초기화 지연, 계산 지연 방식으로 실제 객체가 필요할 때 까지 객체를 생성하지 않음
   - getService 메서드가 MyServiceImpl에 의존한다.
   - 테스트 시 service가 null인 경우와 아닌 경우를 테스트 해봐야 함
     - 작게나마 단일 책임 원칙을 위반
   
 - Main 분리
   - 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮긴다.
   - 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모르도록 한다.
 - 팩토리
 - 의존성 주입
 
 - 확장
   - **처음부터 올바르게** 시스템을 만들 수 있을까?
     - 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현한다.
     - 내일은 새로운 스토리에 맞춰서 조정하고 확장한다.
       - 반복적이고 점진적인 애자일 방식의 핵심
 
 - 횡단(cross-cutting) 관심사
   - AOP에서 관점이라는 모듈 구성 개념
     - 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다.
 
 - 자바 프록시
   - 프록시를 사용하면 코드를 깨끗하게 짜기 어렵다.
   - 시스템 단위로 실행 '지점'을 명시하는 메커니즘도 제공하지 않는다.
     - AOP를 구현하는 기법과 AOP를 구별해야한다.
     - AOP의 진정한 가치는 시스템 동작을 간결하고 모듈화된 방식으로 명시하는 능력이다.
 
 - 테스트 주도 시스템 아키텍처 구축
   - 코드수준에서 아키텍처 관심사를 분리할 수 있다면, 테스트 주도 아키텍처 구축이 가능해진다.

 - 의사 결정을 최적화하라
   - **때때로 가능한 마지막 순간까지 결정을 미루는 방법이 최선이다.**
 
 - 명백한 가치가 있을 때 표준을 현명하게 사용하라.
 - 시스템은 도메인 특화 언어가 필요하다.
</pre>

# 창발성
 - 창발적 설계로 깔끔한 코드를 구현하자
 - 단순한 설계 규칙 네 가지 **[켄트 벡]**
 - **코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없다. 테스트 케이스가 있으므로!**
   - 모든 테스트를 실행한다.
     - 모든 테스트 케이스를 통과하는 시스템 -> 테스트가 가능한 시스템
   - 중복을 없앤다.
     - 깔끔한 시스템을 만들려면 단 몇줄이라도 중복을 제거하겠다는 의지가 필요하다.
     - TEMPLATED METHOD 패턴은 고차원 중복을 제거할 목적으로 자주 사용하는 기법
   - 프로그래머 의도를 표현한다.
     - 자신이 이해하는 코드는 짜기 쉽다.
     - 좋은 이름을 선택하라.
     - 함수와 클래스의 크기를 줄여라.
     - 표준 명칭을 사용해라.
     - 단위 테스트 케이스를 꼼꼼히 작성해라.
     - 표현력을 높이는 가장 큰 방법은 **노력**이다.
   - 클래스와 메서드 수를 최소로 줄인다.
     - 클래스마다 무조건 인터페이스를 구현해라.
     - 자료 클래스와 동작 클래스는 무조건 분리해라.
   
   - **경험을 대신할 단순한 개발 기법은 없다. 단순한 설계 규칙을 따라야 우수한 기법과 원칙을 단번에 활용할 수 있다.**

 
