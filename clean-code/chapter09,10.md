# 단위 테스트
 - TDD 법칙 세 가지
   - 첫째 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
   - 둘째 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 작성한다.
   - 셋째 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
 
 - 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.
 
 - 깨끗한 테스트 코드 유지하기
   - 테스트 코드가 지저분할수록 변경하기 어려워진다.
   - 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 길어진다.

 - 의도하지 않은 결함 수가 많아지면 개발자는 변경을 주저한다.
   - 변경 시 득보다 해가 크다고 생각해 코드를 정리하지 않는 순간, 코드는 망가지기 시작한다.

 - 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
 - 테스트케이스가 없다면 모든 변경이 잠정적인 버그다.
 - **실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다.**
 
 - 깨끗한 테스트코드
   - **BUILD-OPERRATE-CHECK** 패턴이 테스트 구조에 적합하다.
      - 1. 테스트 자료를 만듬
      - 2. 테스트 자료를 조작
      - 3. 조작 결과를 확인
 
 - 도메인에 특화된 테스트 언어
   - API위에 함수와 유틸리티를 구현해 간결하고 표현력이 풍부한 테스트 코트를 짤 것.
 
 - 이중표준
   - 테스트 코드의 표준과 실제 코드의 표준은 다르다
   ```
   @Test
   public void turnOnLoTempAlarmAtThreashold() throw Exception {
       hw.setTemp(WAY_TOO_COLD);
       controller.tic();
       assertTrue(hw.heaterState());
       assertTrue(hw.blowerState());
       assertFalse(hw.coolerState());
       assertFalse(hw.hiTempState());
       assertTrue(hw.loTempState());
   }
   ```
   ```
   @Test
   public void turnOnLoTempAlarmAtThreashold() throw Exception {
       wayTooCold();
       assertEquals("HBchL", hw.getState());
   ```
   - 그릇된 정보를 피하라는 규칙에는 위반되지만, 의미를 안다면 테스트 코드를 더 이해하기 쉽다.

 - 테스트 당 assert 하나
   - 결론이 하나라 코드를 이해하기 쉽고 빠르다.
   - 테스트를 분리하면 중복되는 코드가 많아진다.
     - TEMPLATE METHOD 패턴을 사용하면 중복을 제거할 수 있다.
     - TEMPLATE METHOD : 어떤 작업을 처리하는 일부분을 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정단계에서 수행하는 내역을 바꾸는 패턴
     - 중복을 제거 할 방법은 있지만 차라리 assert문을 여럿 사용하는 편이 낫다.

 - 테스트당 assert 하나보다 테스트당 개념하나 라는 규칙이 더 낫다.

 - **F.I.R.S.T**
   - Fast: 테스트는 빨라야한다.
   - Independent : 의존해선 안된다.
   - Repeatable : 반복 가능해야한다.
   - Self-Validating : 부울값으로 결과를 내야한다.
   - Timely : 적시에 작성해야 한다.
<br/>

# 클래스
 - 클래스 체계
   - 캡슐화 : 변수와 유틸리티는 가능한 공개하지 않는 편이 낫지만, 숨겨야 한다는 법칙도 없다.
   - 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.
 
 - 클래스는 작아야한다.
   - 클래스는 책임의 수로 크기를 센다.
   - 클래스 이름은 해당 클래스 이름을 기술해야 한다.
 
 - 단일 책임 원칙
   - 깨끗하고 체계적인 소프트웨어 보다 돌아가는 소프트웨어를 초점을 맞춘다.
   - 복잡성을 다루려면 체계적인 정리가 필수다.
   - 큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.

 - 응집도
   - 응집도가 높은 클래스를 선호한다.
     - 모든 인스턴스 변수를 메서드마다 사용하는 클래스는 응집도가 높다.
   - **함수를 작게, 매개변수 목록을 짧게** 하다보면 몇몇 메서드가 사용하는 인스턴스 변수가 많아진다.
     - -> 새로운 클래스로 쪼개야 한다는 신호
   - 응집도를 유지하면 작은 클래스 여럿이 나온다.
   
 - 변경하기 쉬운 클래스.
   - 대다수 시스템은 지속적인 변경이 가해진다.
   - 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.

 - 변경으로부터 격리.
   - 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.
